            +---------------------------+
            | CSCC69                    |
            | PROJECT 3: VIRTUAL MEMORY	|
            | DESIGN DOCUMENT           |
            +---------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

FirstName LastName <email@domain.example>
FirstName LastName <email@domain.example>
FirstName LastName <email@domain.example>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

            PAGE TABLE MANAGEMENT
            =====================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

enum page_type is used to identify type of page entries in the supplement page table.
    enum page_type
    {
        PAGE_ZERO,
        PAGE_SWAP,
        PAGE_FILESYS, // mmap
        PAGE_STACK,
        PAGE_NONE,
    };

page table entry:
    struct page
    {
        struct hash_elem elem;
        const void *uaddr;
        void *kaddr;
        uint32_t *pte;
        enum page_type type;
        bool writable;

        struct
        {
            int mapid; // if status is PAGE_FILESYS
            int off;   // a page may be part of a mmap
        } mmap;
        swapid_t swapid; // if status os PAGE_SWAP
    };

---- ALGORITHMS ----

>> A2: In a few paragraphs, describe your code for accessing the data
>> stored in the SPT about a given page.

First, check if the given page is in the supplemental table of the thread.
If there is not a frame for this page, (the type of the page may be SWAP, ZERO, or FILESYS),
then allocate a frame for this page, and call page_load to fill this frame;

>> A3: How does your code coordinate accessed and dirty bits between
>> kernel and user virtual addresses that alias a single frame, or
>> alternatively how do you avoid the issue?

We only access user data through user virtual address to avoid this issue.

---- SYNCHRONIZATION ----

>> A4: When two user processes both need a new frame at the same time,
>> how are races avoided?

There is a global lock for frame_table. One process would wait for another one finishing.

---- RATIONALE ----

>> A5: Why did you choose the data structure(s) that you did for
>> representing virtual-to-physical mappings?

We extend the page table, so that is can store more information to help us
implement swap, lazily loading, and mmap.

               PAGING TO AND FROM DISK
               =======================

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

frame entry:
    struct frame
    {
        struct hash_elem elem;
        void *kaddr;
        const struct page *page;
        bool pin;
    };

global frame table and lock for it:
    static struct hash frame_table;
    static struct lock lock;

---- ALGORITHMS ----

>> B2: When a frame is required but none is free, some frame must be
>> evicted.  Describe your code for choosing a frame to evict.

We use the second-chance algorithm (A: access, D: dirty):
    1) try to find a frame such that (A = 0, D = 0);
    2) if no frame found in 1), try to find a frame such that (A = 0, D = 1) and clear A to 0;
    3) goto 1).
   
>> B3: When a process P obtains a frame that was previously used by a
>> process Q, how do you adjust the page table (and any other data
>> structures) to reflect the frame Q no longer has?

When we evict a frame, we set the page->kaddr = NULL, and clear present bit of page->pte.
So when a frame of Q is evicted, the frame is removed from the page table and the supplemental
page table of Q.

>> B4: Explain your heuristic for deciding whether a page fault for an
>> invalid virtual address should cause the stack to be extended into
>> the page that faulted.

If the fault_address is user virtual address which 32 bytes lower than esp, 
it will be identified as an invalid virtual address, otherwise the stack will be extended by one page.

---- SYNCHRONIZATION ----

>> B5: Explain the basics of your VM synchronization design.  In
>> particular, explain how it prevents deadlock.  (Refer to the
>> textbook for an explanation of the necessary conditions for
>> deadlock.)

The frame table and swap table are global, supplemental page table is per-process. 
When a frame be allocating, the order of lock_acquire is:
    1) lock frame_table_lock
    2) lock swap_table_lock (if a frame is be evicted)
    3) unlock swap_table_lock (if a frame is be evicted)
    4) unlock frame_table_lock
The order of lock_acquire is defined, so there is no circular waiting.

>> B6: A page fault in process P can cause another process Q's frame
>> to be evicted.  How do you ensure that Q cannot access or modify
>> the page during the eviction process?  How do you avoid a race
>> between P evicting Q's frame and Q faulting the page back in?

Before a frame is swapped out, it was removed from the page table of Q.
And the corresponding PTE is cleared (by clearing page->pte), so Q cannot
access this frame another more.

>> B7: Suppose a page fault in process P causes a page to be read from
>> the file system or swap.  How do you ensure that a second process Q
>> cannot interfere by e.g. attempting to evict the frame while it is
>> still being read in?

We use a pin flag to tell the eviction algorithm not choose a pinned frame.

>> B8: Explain how you handle access to paged-out pages that occur
>> during system calls.  Do you use page faults to bring in pages (as
>> in user programs), or do you have a mechanism for "locking" frames
>> into physical memory, or do you use some other design?  How do you
>> gracefully handle attempted accesses to invalid virtual addresses?

We do use page faults to bring in pages. The input virtual addresses of syscalls
will be checked by check_user_addr_area(syscall.c) which will check if the page of
a address is in the supplemental page table.

---- RATIONALE ----

>> B9: A single lock for the whole VM system would make
>> synchronization easy, but limit parallelism.  On the other hand,
>> using many locks complicates synchronization and raises the
>> possibility for deadlock but allows for high parallelism.  Explain
>> where your design falls along this continuum and why you chose to
>> design it this way.

We use multiple locks for global data structures to impose parallelism.

             MEMORY MAPPED FILES
             ===================

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

mmap entry:
    struct mmap
    {
        int id;
        struct file *file;
        size_t size;
        int offset;
        bool writeback; // need write back when unmap
        void *start_page;
        struct hash_elem elem;
    };

---- ALGORITHMS ----

>> C2: Describe how memory mapped files integrate into your virtual
>> memory subsystem.  Explain how the page fault and eviction
>> processes differ between swap pages and other pages.

For each process, it keeps a hash table of memory mapped files. 
Each page in the supplemental page table has a type attribute. When a page
fault occurs, `page_load` would be called, and it will check the type of the
page being loaded. If the type of a page is PAGE_FILESYS, page.mmap stores its mmapid.
We use mmapid to get the file in the mmap_table, and read its content to memory.

>> C3: Explain how you determine whether a new file mapping overlaps
>> any existing segment.

Before adding the file to mmap_table, we get the file length and calculate how many pages it
needs. If there is any overlaps, mmap would return -1.

---- RATIONALE ----

>> C4: Mappings created with "mmap" have similar semantics to those of
>> data demand-paged from executables, except that "mmap" mappings are
>> written back to their original files, not to swap.  This implies
>> that much of their implementation can be shared.  Explain why your
>> implementation either does or does not share much of the code for
>> the two situations.

We share the implementation of mmap and loading executables. But when a process exits,
pages mapped to executables should not be written back. We add an argument of `bool writeback` 
for `mmap_add` function to indicate that this 'map' do not need writing back.

               SURVEY QUESTIONS
               ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?
